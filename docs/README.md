# Introduction
EasySourcing is an API for building high performance Event Driven and Event Sourcing applications. It is built on top of Apache Kafka and Kafka Streams. This means that applications built with EasySourcing are highly scalable and fault-tolerant. You can run multiple instances of your applications and loadbalancing is done for you automatically. 

 - - - -

# Quick Start
- - - -
## Install
Include the `easysourcing` dependency in your project:
```javascript
<dependency>
  <groupId>com.github.alikelleci</groupId>
  <artifactId>easysourcing</artifactId>
  <version>VERSION</version>
</dependency>
```

## Aggregate
The very first step is to model our domain. In the following example customer is considered as our aggregate: 

```javascript
@Value
@Builder(toBuilder = true)
public class Customer {
  @AggregateId
  private String id;  
  private String firstName;
  private String lastName;
  private String address;
  
  // Getters & setters are generated by Lombok
}
```
Each aggregate is required to have an aggregate identifier annotated with `@AggregateId`. As without it, EasySourcing will not know to which aggregate a given command is targeted. In the code snippet above we also use Lombok annotations to reduce some of the boilerplate code. 

The next step is to create commands and events for our aggregate.

**Commands**
```javascript
@TopicInfo("customer-commands")
public interface CustomerCommand {

  @Value
  @Builder
  class CreateCustomer implements CustomerCommand {
    @AggregateId
    private String customerId;
    private String firstName;
    private String lastName;
  }

  @Value
  @Builder
  class ChangeFirstName implements CustomerCommand {
    @AggregateId
    private String customerId;
    private String firstName;
  }
}
```

**Events**
```javascript
@TopicInfo("customer-events")
public interface CustomerEvent {

  @Value
  @Builder
  class CustomerCreated implements CustomerEvent {
    @AggregateId
    private String customerId;
    private String firstName;
    private String lastName;
  }

  @Value
  @Builder
  class FirstNameChanged implements CustomerEvent {
    @AggregateId
    private String customerId;
    private String firstName;
  }
}
```

In the code snippets above, we have defined some commands and events for our aggregate. We annotate our target aggregate identifier with `@AggregateId`. Another important annotation is `@TopicInfo`. In here, we specifiy in which topic to store our commands and events.

> **Best practises for choosing topic names:** 
* Choose different topic names for commands and events.
* Choose different topic names for each aggregate type, for example 'customer-events' and 'order-events'.
* Avoid topic names based on things that change, for example team name, topic owner, service name, product name, and consumer name.
* Avoid topic names based on information that would be stored in other places.

## Command handler
Now that we have defined our commands and events, its time to create a command handler. You can create a command handler by simply annotating your command handling methods with `@HandleCommand`:

```javascript
public class CustomerCommandHandler {

  @HandleCommand
  public CustomerEvent handle(Customer currentState, CreateCustomer command) {
    if (currentState == null) {
      return null;  // Customer already exists!
    }
    return CustomerCreated.builder()
        .customerId(command.getCustomerId())
        .firstName(command.getFirstName())
        .lastName(command.getLastName())
        .build();
  }

  @HandleCommand
  public CustomerEvent handle(Customer currentState, ChangeFirstName command) {
    if (currentState == null) {
      return null; // Customer does not exists!
    }
    return FirstNameChanged.builder()
        .customerId(command.getCustomerId())
        .firtname(command.getFirstName())
        .build();
  }
}
```
The first parameter of the command handling method is the current state of the aggregate. The second parameter is the command that is being handeled. A command handler's responsibility is to validate a command against the current state of the aggregate. If the command is valid, we return one or more events.

> **Best practises for command handlers:** 
* Command handlers should be pure functions and should not block execution.
* Command handlers should only perform validation checks and return 0..n events.
* Don't call external systems to validate your aggregate. If you need to, then consider if you got your aggregate boundaries correct.
* Don't put logic like sending out emails or updating view models in command handlers. These kind of logic should rather be executed in event handlers. 

## Aggregator
An aggregator applies events to the current state of the aggregate and returns a new updated state. Below we see an example of the customer aggregator:

```javascript
public class CustomerAggregator {

  @ApplyEvent
  public Customer apply(Customer currentState, CustomerCreated event) {
    return Customer.builder()
        .id(event.getCustomerId())
        .firstName(event.getFirstName())
        .lastName(event.getLastName())
        .build();
  }

  @ApplyEvent
  public Customer apply(Customer currentState, FirstNameChanged event) {
    return currentState.toBuilder()
        .firstName(event.getFirstName())
        .build();
  }
}
```
We annotate our aggregator methods with `@ApplyEvent`. These methods takes two parameters, the first one is the current state of the aggregate and the second parameter is the event to apply. The return value of an aggregator method should always be the **type of the aggregate**. In this case, we return a new copy of the customer with updated state. Although it is not required to return a new copy, it is recommended that you use immutable objects as much as possible.

> **Best practises for aggregators:** 
* Aggregators should be pure functions and should not block execution.
* Aggregators should not have any side effects and they should not modify the passed aggregate state. They should rather do a deep copy of the passed aggregate, apply the event and return this altered aggregate.

## Event handler
Event handlers are components that act on incoming events. They are often used in external systems to get notifications about things that happened. In reaction to that, event handlers can execute their own logic. Usually, this involves updating view models or forwarding updates to other components.

See below for an example of a customer event handler:
```javascript
public class CustomerEventHandler {

  @HandleEvent
  public void handle(CustomerCreated event) {
    emailClient.sendEmail("Welcome " + event.getFirstName())  // Send a welcome email
  }

  @HandleEvent
  public SomeCommand handle(FirstNameChanged event) {
    return new SomeCommand(); // send a command
  }
}
```
Methods annotated with `@HandleEvent`will get triggered when the corresponding event occurs. Event handlers can also send commands in reaction to an event. This is usefull when you implement a saga-pattern. To send a command, simply return a java object that represents your command. You can also return a list of commands. 

> **Event handlers are often used in external systems for updating view models or sending out emails. They are also used for implementing a saga-pattern.**

## Putting it all together 
Now that we have everything set up, its time to wiring it togetger:
```javascript
public class App {
  
  public static void main(String[] args) {
    Config config = Config.builder()
        .applicationId("customer-service")
        .bootstrapServers("localhost:9092")
        .partitions(1)
        .replicas(1)
        .build();

    EasySourcing app = new EasySourcingBuilder()
        .withConfig(config)
        .registerHandler(new CustomerCommandHandler())
        .registerHandler(new CustomerAggregator())
        .registerHandler(new CustomerEventHandler())
        .build();
        
    app.start();
  }
}
```

Sending commands is as easy as:
```javascript
public class Sender {
  
  public static void main(String[] args) {
    Config config = Config.builder()
        .bootstrapServers("localhost:9092")
        .build();

    CommandGateway commandGateway = new GatewayBuilder()
        .withConfig(config)
        .commandGateway();
        
    CreateCustomer command = CreateCustomer.builder()
        .customerId("cust-123")
        .firstName("John")
        .lastName("Doe")
        .build();
    
    commandGateway.send(command);
  }
}
```
# Spring Boot
- - - -
EasySourcing also includes a `easysourcing-spring-boot-starter`, so you can benefit from auto-configuration and use it with Spring Boot. Make sure you have followed the quickstart guide before you continue reading this chapter.

## Install
Include the `spring-boot-starter` dependency in your project:
```javascript
<dependency>
  <groupId>com.github.alikelleci</groupId>
  <artifactId>easysourcing-spring-boot-starter</artifactId>
  <version>VERSION</version>
</dependency>
```

## Handlers
There is not much of a difference in your command handlers and aggregators when using the `easysourcing-spring-boot-starter` dependency. The only difference is that you have to annotate your handlers with the appropriate annotation:

* Use `@CommandHandler` for your command handlers.
* Use `@Aggregator` for your aggregators.
* Use `@EventHandler` for your event handlers.

See below for an example:
```javascript
@CommandHandler
public class CustomerCommandHandler {
  @HandleCommand
  public CustomerEvent handle(Customer currentState, CreateCustomer command) {
    // logic omitted
  }
}
````
>**These annotations make your handlers a spring bean, so you can do your autowiring as usual. Also, you don't have to register your handlers manually, as this is done automatically for you.**


# Reference

 - - - -
