# Introduction
EasySourcing is an API for building high performance Event Driven and Event Sourcing applications. It is built on top of Kafka Streams and uses Kafka as backbone. This means that applications built with EasySourcing are highly scalable and fault-tolerant.

 - - - -

# Quick Start
- - - -

## Aggregate
The very first step is to model our domain. In the following example customer is considered as our aggregate: 

```javascript
@Value
@Builder(toBuilder = true)
public class Customer {
  @AggregateId
  private String id;  
  private String firstName;
  private String lastName;
  private String address;
  
  // Getters & setters are generated by Lombok
}
```
Each aggregate is required to have an aggregate identifier annotated with `@AggregateId`. As without it, EasySourcing will not know to which aggregate a given command is targeted. In the code snippet above we also use Lombok annotations to reduce some of the boilerplate code. 

The next step is to create commands and events for our aggregate.

**Commands**
```javascript
@TopicInfo("customer-commands")
public interface CustomerCommand {

  @Value
  @Builder
  class CreateCustomer implements CustomerCommand {
    @AggregateId
    private String customerId;
    private String firstName;
    private String lastName;
  }

  @Value
  @Builder
  class ChangeFirstName implements CustomerCommand {
    @AggregateId
    private String customerId;
    private String firstName;
  }
}
```

**Events**
```javascript
@TopicInfo("customer-events")
public interface CustomerEvent {

  @Value
  @Builder
  class CustomerCreated implements CustomerEvent {
    @AggregateId
    private String customerId;
    private String firstName;
    private String lastName;
  }

  @Value
  @Builder
  class FirstNameChanged implements CustomerEvent {
    @AggregateId
    private String customerId;
    private String firstName;
  }
}
```

In the code snipsets above, we have defined some commands and events for our aggregate. We annotate our target aggregate identifier with `@AggregateId`. Another important annotation is `@TopicInfo`. In here, we specifiy in which topic to store our commands and events.

> **Best practises for choosing topic names:** 
* Choose different topic names for commands and events.
* Choose different topic names for each aggregate type, for example 'customer-events' and 'order-events'.
* Avoid topic names based on things that change, for example team name, topic owner, service name, product name, and consumer name.
* Avoid topic names based on information that would be stored in other places.

## Command handler
Now that we have defined our commands and events, its time to create a command handler. You can create a command handler by simply annotating your command handling methods with `@HandleCommand`:

```javascript
public class CustomerCommandHandler {

  @HandleCommand
  public CustomerEvent handle(Customer currentState, CreateCustomer command) {
    if (currentState == null) {
      return null;  // Customer already exists!
    }
    return CustomerCreated.builder()
        .customerId(command.getCustomerId())
        .firstName(command.getFirstName())
        .lastName(command.getLastName())
        .build();
  }

  @HandleCommand
  public CustomerEvent handle(Customer currentState, ChangeFirstName command) {
    if (currentState == null) {
      return null; // Customer does not exists!
    }
    return FirstNameChanged.builder()
        .customerId(command.getCustomerId())
        .firtname(command.getFirstName())
        .build();
  }
}
```
The first parameter of the command handling method is the current state of the aggregate. The second parameter is the command that is being handeled. A command handler's responsibility is to validate a command against the current state of the aggregate. If the command is valid, we return one or more events.

> **Best practises for command handlers:** 
* Command handlers should be pure functions and should not block execution.
* Command handlers should only perform validation checks and return 0..n events.
* Don't call external systems to validate your aggregate. If you need to, then consider if you got your aggregate boundaries correct.
* Don't put logic like sending out emails or updating view models in command handlers. These kind of logic should rather be executed in event handlers. 

## Aggregator
An aggregator applies events to the current state of the aggregate and returns a new updated state. Below we see an example of the customer aggregator:

```javascript
public class CustomerAggregator {

  @ApplyEvent
  public Customer apply(Customer currentState, CustomerCreated event) {
    return Customer.builder()
        .id(event.getCustomerId())
        .firstName(event.getFirstName())
        .lastName(event.getLastName())
        .build();
  }

  @ApplyEvent
  public Customer apply(Customer currentState, FirstNameChanged event) {
    return currentState.toBuilder()
        .firstName(event.getFirstName())
        .build();
  }
}
```
We annotate our aggregator methods with `@ApplyEvent`. These methods takes two parameters, the first one is the current state of the aggregate and the second parameter is the event to apply. The return value of an aggregator method should always be the **type of the aggregate**. In this case, we return a new copy of the customer with updated state. Although it is not required to return a new copy, it is recommended that you use immutable objects as much as possible.

> **Best practises for aggregators:** 
* Aggregators should be pure functions and should not block execution.
* Aggregators should not have any side effects and they should not modify the passed aggregate state. They should rather do a deep copy of the passed aggregate, apply the event and return this altered aggregate.

## Event handler
Event handlers are components that act on incoming events. They are often used in external systems to get notifications about things that happened. In reaction to that, event handlers can execute ther own logic. Usually, this involves updating view models or forwarding updates to other components.

Below we see an example of an event handler where we react on customer events:
```javascript
public class CustomerEventHandler {

  @HandleEvent
  public void handle(CustomerCreated event) {
    emailClient.sendEmail("Welcome " + event.getFirstName())  // Send a welcome email
  }

  @HandleEvent
  public SomeCommand handle(FirstNameChanged event) {
    return new SomeCommand(); // send a command
  }
}
```
Methods annotated with `@HandleEvent`will get triggered when the corresponding event occurs. Event handlers can also send commands in reaction to an event. This is usefull when you implement a saga-pattern. To send a command, simply return a java object that represents your command. You can also send a list of commands. 

> **Event handlers are often used in external systems for updating view models or sending out emails. They are also used for implementing a saga-pattern.**

## Putting it all together 
Now that we have everything in place, its time to wiring it togetger:
```javascript
public class Main {
  
  public static void main(String[] args) throws InterruptedException {
    Config config = Config.builder()
        .applicationId("customer-service")
        .bootstrapServers("localhost:9092")
        .partitions(1)
        .replicas(1)
        .build();

    EasySourcing app = new EasySourcingBuilder()
        .withConfig(config)
        .registerHandler(new CustomerCommandHandler())
        .registerHandler(new CustomerAggregator())
        .registerHandler(new CustomerEventHandler())
        .build();
        
    app.start();
  }
}
```
# Reference

 - - - -
