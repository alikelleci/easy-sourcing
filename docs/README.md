# Introduction
EasySourcing is an API for building high performance Event Driven and Event Sourcing applications. It is built on top of Apache Kafka and Kafka Streams. This means that applications built with EasySourcing are highly scalable and fault-tolerant. You can run multiple instances of your applications and loadbalancing is done for you automatically. 

 - - - -

# Quick Start

## Install
Include the dependency in your project:
```javascript
<dependency>
  <groupId>com.github.alikelleci</groupId>
  <artifactId>easysourcing</artifactId>
  <version>VERSION</version>
</dependency>
```

Alternatively, if you are using **Spring Boot**, you can include the `easysourcing-spring-boot-starter` dependency and benefit from auto-configuration:
```javascript
<dependency>
  <groupId>com.github.alikelleci</groupId>
  <artifactId>easysourcing-spring-boot-starter</artifactId>
  <version>VERSION</version>
</dependency>
```

## Command handling

### Aggregate
The very first step is to model our domain. In the following example customer is considered as our aggregate: 

```javascript
@Value
@Builder(toBuilder = true)
public class Customer {
  @AggregateId
  private String id;  
  private String firstName;
  private String lastName;
  private String address;
  
  // Getters & setters are generated by Lombok
}
```
Each aggregate is required to have an aggregate identifier annotated with `@AggregateId`. As without it, EasySourcing will not know to which aggregate a given command is targeted. In the code snippet above we also use Lombok annotations to reduce some of the boilerplate code. 

The next step is to create commands and events for our aggregate.

**Commands**
```javascript
@TopicInfo("customer-commands")
public interface CustomerCommand {

  @Value
  @Builder
  class CreateCustomer implements CustomerCommand {
    @AggregateId
    private String customerId;
    private String firstName;
    private String lastName;
  }

  @Value
  @Builder
  class ChangeFirstName implements CustomerCommand {
    @AggregateId
    private String customerId;
    private String firstName;
  }
}
```

**Events**
```javascript
@TopicInfo("customer-events")
public interface CustomerEvent {

  @Value
  @Builder
  class CustomerCreated implements CustomerEvent {
    @AggregateId
    private String customerId;
    private String firstName;
    private String lastName;
  }

  @Value
  @Builder
  class FirstNameChanged implements CustomerEvent {
    @AggregateId
    private String customerId;
    private String firstName;
  }
}
```

In the code snippets above, we have defined some commands and events for our aggregate. We annotate our target aggregate identifier with `@AggregateId`. Another important annotation is `@TopicInfo`. In here, we specifiy in which topic to store our commands and events.

> **Best practises for choosing topic names:** 
* Choose different topic names for commands and events.
* Choose different topic names for each aggregate type, for example 'customer-events' and 'order-events'.
* Avoid topic names based on things that change, for example team name, topic owner, service name, product name, and consumer name.
* Avoid topic names based on information that would be stored in other places.

### Command handler
Now that we have defined our commands and events, its time to create a command handler. You can create a command handler by simply annotating your command handling class with `@CommandHandler` and your command handling methods with `@HandleCommand`:

```javascript
@CommandHandler
public class CustomerCommandHandler {

  @HandleCommand
  public CustomerEvent handle(Customer currentState, CreateCustomer command) {
    if (currentState == null) {
      return null;  // Customer already exists!
    }
    return CustomerCreated.builder()
        .customerId(command.getCustomerId())
        .firstName(command.getFirstName())
        .lastName(command.getLastName())
        .build();
  }

  @HandleCommand
  public CustomerEvent handle(Customer currentState, ChangeFirstName command) {
    if (currentState == null) {
      return null; // Customer does not exists!
    }
    return FirstNameChanged.builder()
        .customerId(command.getCustomerId())
        .firtname(command.getFirstName())
        .build();
  }
}
```
The first parameter of the command handling method is the current state of the aggregate. The second parameter is the command that is being handeled. A command handler's responsibility is to validate a command against the current state of the aggregate. If the command is valid, we return one or more events.

> **Best practises for command handlers:** 
* Command handlers should be pure functions and should not block execution.
* Command handlers should only perform validation checks and return 0..n events.
* Don't call external systems to validate your aggregate. If you need to, then consider if you got your aggregate boundaries correct.
* Don't put logic like sending out emails or updating view models in command handlers. These kind of logic should rather be executed in event handlers. 

### Aggregator
An aggregator applies events to the current state of the aggregate and returns a new updated state. Below we see an example of the customer aggregator:

```javascript
@Aggregator
public class CustomerAggregator {

  @ApplyEvent
  public Customer apply(Customer currentState, CustomerCreated event) {
    return Customer.builder()
        .id(event.getCustomerId())
        .firstName(event.getFirstName())
        .lastName(event.getLastName())
        .build();
  }

  @ApplyEvent
  public Customer apply(Customer currentState, FirstNameChanged event) {
    return currentState.toBuilder()
        .firstName(event.getFirstName())
        .build();
  }
}
```
We annotate our aggregator class with `@Aggregator` and the aggregating methods with `@ApplyEvent`. These methods takes two parameters, the first one is the current state of the aggregate and the second parameter is the event to apply. The return value of an aggregator method should always be the **type of the aggregate**. In this case, we return a new copy of the customer with updated state. Although it is not required to return a new copy, it is recommended that you use immutable objects as much as possible.

> **Best practises for aggregators:** 
* Aggregators should be pure functions and should not block execution.
* Aggregators should not have any side effects and they should not modify the passed aggregate state. They should rather do a deep copy of the passed aggregate, apply the event and return this altered aggregate.

### Dispatching commands

Sending commands is as easy as:
```javascript
public class CommandSender {
  
  public static void main(String[] args) {
    Config config = Config.builder()
        .bootstrapServers("localhost:9092")
        .build();

    CommandGateway commandGateway = new GatewayBuilder()
        .withConfig(config)
        .commandGateway();
        
    CreateCustomer command = CreateCustomer.builder()
        .customerId("cust-123")
        .firstName("John")
        .lastName("Doe")
        .build();
    
    commandGateway.send(command);
  }
}
```

> **Spring Boot** 

When using Spring Boot, you can just autowire an instance of `CommandGateway`.

## Event handling

### Event handler
Event handlers are components that act on incoming events. They are often used in external systems to get notifications about things that happened. In reaction to that, event handlers can execute their own logic. Usually, this involves updating view models or forwarding updates to other components.

See below for an example of a customer event handler:
```javascript
@EventHandler
public class CustomerEventHandler {

  @HandleEvent
  public void handle(CustomerCreated event) {
    emailClient.sendEmail("Welcome " + event.getFirstName())  // Send a welcome email
  }

  @HandleEvent
  public SomeCommand handle(FirstNameChanged event) {
    return new SomeCommand(); // send a command
  }
}
```
We annotate event handler classes  with `@EventHandler`. Methods annotated with `@HandleEvent`will get triggered when the corresponding event occurs. Event handlers can also send commands in reaction to an event. This is usefull when you implement a saga-pattern. To send a command, simply return a java object that represents your command. You can also return a list of commands. 

> **Event handlers are often used in external systems for updating view models or sending out emails. They are also used for implementing a saga-pattern.**

### Dispatching events

Sending events is as follows:
```javascript
public class EventSender {
  
  public static void main(String[] args) {
    Config config = Config.builder()
        .bootstrapServers("localhost:9092")
        .build();

    EventGateway eventGateway = new GatewayBuilder()
        .withConfig(config)
        .eventGateway();
        
    CustomerCreated event = CustomerCreated.builder()
        .customerId("cust-123")
        .firstName("John")
        .lastName("Doe")
        .build();
    
    eventGateway.send(event);
  }
}
```

> **Spring Boot** 

When using Spring Boot, you can just autowire an instance of `EventGateway`.


## Putting it all together 
Now that we have everything set up, its time to wiring it together:

```javascript
public class App {
  
  public static void main(String[] args) {
    Config config = Config.builder()
        .applicationId("customer-service")
        .bootstrapServers("localhost:9092")
        .build();

    EasySourcing app = new EasySourcingBuilder()
        .withConfig(config)
        .registerHandler(new CustomerCommandHandler())
        .registerHandler(new CustomerAggregator())
        .registerHandler(new CustomerEventHandler())
        .build();
        
    app.start();
  }
}
```

> **Spring Boot**

If you are using Spring Boot with the `easysourcing-spring-boot-starter` dependency, then you don't have to do the steps above. Just add the essential configurations in your `application.properties`:

* easysourcing.application-id=customer-service
* easysourcing.bootstrap-servers=localhost:9092

 - - - -
 
# Reference
 
## Configuration
The essential configurations for EasySourcing are the following:

| Option           	| Default value 	| Description                                                                                                                    	|
|------------------	|---------------	|--------------------------------------------------------------------------------------------------------------------------------	|
| applicationId    	|               	| An identifier for the stream processing application. Must be unique within the Kafka cluster.                                  	|
| bootstrapServers 	|               	| Comma-seperated host/port pairs to use for establishing the initial connection to the Kafka cluster.                           	|
| partitions       	| 1             	| Sets the amount of partitions for the topics created by the applicaiton.                                                       	|
| replicas         	| 1             	| Sets the replication factor for the topics created by the applicaiton.                                                         	|
| securityProtocol 	| PLAINTEXT     	| Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.                         	|
| frequentCommits  	| false         	| Sets frequent commits on or off. Setting this option to 'true' will increase reliability but will drastically reduce performance. |


## Retries
EasySourcing has a built in mechanism for retrying command handling and/or event handling. To enable retry, simply annotate your handler method with `@Retry`:

```javascript
@EventHandler
public class CustomerEventHandler {

  @Retry
  @HandleEvent
  public void handle(SomeEvent event) {
     // Some operation that can throw an Exception
  }

  @Retry(exceptions = {TimeoutException.class, SocketTimeoutException.class}, attempts = 3, delay = 3000, backoff = Backoff.EXPONENTIAL)
  @HandleEvent
  public SomeCommand handle(AnotherEvent event) {
     // Some operation that can throw a TimeoutException or SocketTimeoutException
  }

}
```
> **Options**

Several options are available to configure retry policy based on your needs:

| Option     	| Default value 	| Description                                                                                           	|
|------------	|---------------	|-------------------------------------------------------------------------------------------------------	|
| exceptions 	|               	| Exception types that are retryable. Defaults to any exception.                                        	|
| attempts   	| 3             	| The maximum number of attempts before failure.                                                        	|
| delay      	| 1000          	| The maximimum wait (in milliseconds) between retries.                                                 	|
| backoff    	| FIXED         	| Specify the backoff strategy for retrying this operation. Valid values are 'FIXED' and 'EXPONENTIAL'. 	|
